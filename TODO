Inste



MOMENT:
  
  IDEAL CLOSURE BEHAVIOR

ORDER OF OPS
    1. Local scope
    2. Object Cache
    3. Compile scope


1. Store mapping of routes to objects in scope during
   closure compilation.

    + utilize object w/ underscores or something in 
      place of colons


2. For everything but set, dereference vars with this
   mapping first (after checking local scope), and
   when matches aren't found, use inherited context.

    + Will need to implement getAttribute 


3. For set, skip object cache and just check local 
   scope and compile scope. If set overrides a cached
   object, remove that object (and nested) from cache.

    + Need setAttribute




OR




Have set, def, and unroute functions check for a _mappings internal

def:
    just act normally.

set:
    if route is in mappings, set in parent context, update mappings,
    and .... on parent set, check that parent hasn't been collected  ^^^^

unroute:
    check mappings after locals

closure:
    1. form and inject mappings
    2. inject parent scope (as non-referenced internal)



(def makeCounter {
  (def i 0)
  (if @:size {
    (i:= (@:get 0))
  })
  (return {
    (def r (i:$))
    (i:++)
    (return r)
  })
})



NOW:

 Modules:
   + CLI
   + Runtime



 + Make address type

 + Make legit ':' operator.

 + Form iterator idioms

 + Add (implements x y) function for interface checking.

 + Fix hashmap.

 + Make regex module

 + Make Go-inspired defer

 + Make break and continue accept arguments to deal with
   nested loops.

 + Protect against circular prototype linkage.

 + Cap slot name sizes

 + Ensure things run on debug build

 + Make number type handle infinite precision integers?, binary,
   and hex, as well as the existing double. Magic.

 + Make argument expansion/pass

 + Maybe make it so callMethod doesn't try underscore 

 + Use standardized hash algo for importe

 + Make set more method like 



MAJOR:

 + Design and implement standard library.

 + Consolidate memory using a hybrid free list instead of
   fragmented malloc calls all over the place. Capitalize
   on repeat object sizes.




MEDIUM:

 + Handle exception catch cleanups.
 
 + Replace slot system with legit accessor.

 + Prefix operators...

 + Implement macros

 + Generators

 + Object notation (maybe brackets and scrap macros?)

 + Make composition functions for objects 
     - &=: and in place (intersection)
     - |=: or in place (union)
     - 

 + Make clonable Runtime module for executing sub programs



MINOR:

 + Improve internal module code scanner. Use regex
   or something.




MAYBE:
 
 + Make carrots variable expansion operators.

 + Prototype multiplexing (multiple inheritance).




LATER:
  + Concurrency!!!