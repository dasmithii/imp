Overview

    Imp is a little scripting language I'm working on for fun. It 
    is dynamic, prototype-based, and excessively parenthesized.

      >  (print 'Hello, world!')
    


Tutorial

                        Grouping Operators

    Above, parentheses activate the printer object with a single
    argument. Resulting is an instance of software's greatest
    clichÃ©. The following produces identical output:

      >  (print [{(return 'Hello, world')}])

    This is because, in imp, parentheses are function calls; curly
    braces define code blocks; and hard brackets expand macros. In
    this snippet, the macro expansion evaluates to 'Hello, world',
    and thus we have (print 'Hello, world').

    Note the similarity between function calls and macro
    expansions. Each requires one activate-able object and may
    accept arbitrary arguments. Accordingly, activate-able objects
    can be used for either purpose. There is no difference in
    semantics between macro code and runtime-executed code, as
    there is in C.


                         The Object System

    Imp is dynamic and duck-typed (meaning that there are no 
    compile-time distinctions between object types, and that,
    instead, objects are permitted wherever they are capable of
    going). So, essentially, there exists only one type: the
    object, which comprises arbitrary fields that are themselves 
    nested objects (except in the case of built-ins).

    Object fields are accessible via the colon operator and can be
    managed with the built-in 'def', 'set', and 'rem' functions.

      >  (def a 2)
      >  (set a 3)
      >  (rem a)

      >  (def myObject:mySlot 'hello')
      >  (rem myObject)

    Exceptions are thrown when programmers attempt to access
    fields and methods that do not exist. For example:

      >  (def myObject $)             # Create new (empty) object.
      >  (myObject:nonExistentMethod) # Error!

    Methods are defined and called as follows:

      >  (def myObject $)
      >  (def myObject:vocabulary 'hi')
      >  (def myObject:speak {
            (print self:vocabulary)
         })
      >  (myObject:speak)

    The 'self' variable is injected into block scope. Likewise is
    the 'arguments' variable, a vector of arbitrary length.

    
                         Special and Internal Slots

   Slot names prefixed with an underscore are considered
   'special' in the sense that they should not be mucked with by
   mud-bloods. _prototyp




      


Slots
  
    Everything is an object, and objects are merely collections 
    of slots (i.e. pointers to other objects, or, in some cases,
    raw data).

      (set object:slot)



Special Slots

    Fields prefixed with an underscore are considered 'special'
    and should be handled with care (if at all). These include
    the following:

      +  _prototype
      +  _cleanup
      +  _activate




Internal Slots

    A double underscore prefix is indicative of internal data, 
    which is especially special and required by built-in or 
    library-provided data structures. Avoid mucking with these
    unless you absolutely must (or are curious).

    Commonly slots for housing internals include:

      +  __data
      +  __init
      +  __cleanup
      +  __activate




Object Activation

    The process of object activation, whether in a function call
    or macro expansion, is as follows:

      1. If object has an '_activate' field of built-in type 
         closure, said closure is executed in the object's scope
         and with its arguments.

      2. If object has an '__activate' (double underscore)
         internal field, it is assumed that this field points to
         a C function, which is executed with the arguments: (1)
         runtime, (2) context, (3) calling object, (4) argc, and
         (5) argv.

      3. An error is thrown. Object cannot be activated.
 



